% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/getR.R
\name{getG}
\alias{getG}
\alias{getG.default}
\alias{getG.lme}
\alias{getG.gls}
\alias{getR}
\alias{getR.default}
\alias{getR.lme}
\alias{getR.gls}
\alias{getV}
\alias{getV.default}
\alias{getV.lme}
\alias{getV.gls}
\title{Extract R, G or V matrix in a mixed or GLS model}
\usage{
getG(fit, ...)

\method{getG}{default}(fit, ...)

\method{getG}{lme}(fit, ...)

\method{getG}{gls}(fit, ...)

getR(fit, ...)

\method{getR}{default}(fit, ...)

\method{getR}{lme}(fit, ...)

\method{getR}{gls}(fit, ...)

getV(fit, ...)

\method{getV}{default}(fit, ...)

\method{getV}{lme}(fit, ...)

\method{getV}{gls}(fit, ...)
}
\arguments{
\item{fit}{model created with \code{\link[nlme]{lme}} or 
\code{\link[nlme]{gls}}}

\item{individuals}{for \code{getR} or \code{getV} with
\code{\link[nlme]{lme}} objects, select the clusters for which
variances are returned. If not specified, the variance of the
first cluster is returned.}
}
\value{
For \code{\link[nlme]{lme}} objects, \code{getG} returns
   the between-cluster variance of random effects, \code{getV},
   and \code{getR} returns a list with the within-cluster marginal
   variance and the within-cluster conditional variance respectively
   for the the clusters listed in \code{individuals}. If 
   \code{individuals} is missing, the variance of the first
   cluster is returned. ISSUE: For 
   \code{\link[nlme]{gls}} objects all functions return the same thing but
   uninformatively if correlation is clustered and if weights
   produce differenct variances in the corresponding positions in 
   different clusters.
}
\description{
These functions call \code{\link[nlme]{getVarCov}} in the 
\pkg{nlme} package. They are intended to have names and functions
that are easy to remember.
}
\section{Methods (by class)}{
\itemize{
\item \code{default}: default method

\item \code{default}: default method

\item \code{lme}: lme method

\item \code{gls}: gls method

\item \code{default}: gls method

\item \code{lme}: lme method

\item \code{gls}: gls method
}}

\examples{
library(spida2)
library(nlme)
library(gnew)
data <- expand.grid( Xdev = c(-3,-2,-1,0,1,2,3), id = 1:5 )
 
set.seed(12345)
data <- within(data, {
  Xmean <- 2*id
  X <- Xdev + Xmean
  Y <- (-1 + .1*rnorm(max(id)))[id] * Xdev + 
    2 * Xmean + .3 * id * rnorm(length(id))
})

library(lattice)
gd()
xyplot(Y ~ X, data, groups = id)
fit0 <- lme(Y ~ X, data,
            random = ~ 1+ X |id)
fit <- lme(Y ~ X, data, 
           random = ~ 1 + X | id,
           weights = varConstPower(form = ~ fitted(.)),
           correlation = corAR1(form = ~ 1 | id),
           control = list(returnObject = TRUE))
fitgls <- gls(Y ~ X, data, weights = varConstPower(form = ~ fitted(.)),
           correlation = corAR1(form = ~ 1|id),
           control = list(returnObject = TRUE, maxIter= 1000, 
           verbose = TRUE, msMaxIter = 1000,
               msVerbose=TRUE))
summary(fit)
getVarCov(fit)
getVarCov(fit, individuals = '2')
getVarCov(fit, individuals = '2', type = 'conditional') \%>\% 
  .[[1]] \%>\% 
  diag
getVarCov(fit,  type = 'conditional')\%>\% 
  .[[1]] \%>\% 
  diag

getG(fit)
getR(fit)[[1]]
getV(fit)[[1]]


(Z <- cbind(1, 2+seq(-3,3)))
Z
(getG(fit))

Z \%*\% getG(fit) \%*\% t(Z)

getV(fit)[[1]]
getR(fit)[[1]]
sigma(fit)
getVarCov(fit, type = 'random.effects')
getVarCov(fit)
Z \%*\% getG(fit) \%*\% t(Z)
getV(fit)[[1]] - Z \%*\% getG(fit) \%*\% t(Z) - getR(fit)[[1]]

getG(fit0)
Z \%*\% getG(fit0) \%*\% t(Z)
Z \%*\% getG(fit0) \%*\% t(Z) \%>\% svd \%>\% .$d
getR(fit0)
sigma(fit0)
getV(fit0)
Z \%*\% getG(fit0) \%*\% t(Z) + getR(fit0)[[1]]
}
