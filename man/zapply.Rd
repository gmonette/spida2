% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/zapply.R
\name{zapply}
\alias{zapply}
\alias{zapply.default}
\alias{zapply.formula}
\alias{cvar}
\alias{cvars}
\alias{dvar}
\alias{dvar.factor}
\alias{dvar.default}
\alias{cvar.factor}
\alias{cvar.default}
\alias{zzaply}
\title{Apply a function within each cluster of multilevel data}
\usage{
zapply(x, ...)

zzaply(x, ...)
}
\arguments{
\item{x}{a vector or data frame that provides the first argument of
\code{FUN}}

\item{\dots}{additional variables to be supplied to \code{FUN}}

\item{by}{If \code{x} is a vector: a 'factor' of the same lenth as \code{x}
whose levels identify clusters.  If \code{x} is a data frame, a one-sided
formula that identifies the variable(s) within \code{x} to be used to
clusters.}

\item{FUN}{a function to be applied to \code{x} within each cluster.
\code{FUN} can return a single value, or a vector whose length is equal to
the number of elements in each cluster.}

\item{fmla}{in \code{zapply.formula}, fmla is a two-sided formula as in
\code{\link{aggregate.formula}}. The left-hand side identifies the
variable(s) in \code{data} to be include in a data.frame that is clusterd using
the variables in the right-hand side of the formula.}

\item{x}{vector in zzapply}
}
\value{
When the result in each cell is a scalar, \code{zapply} can be used
     to for multilevel analysis to produce 'contextual variables' computed within
     subgroups of the data and expanded to a constant over elements of each
     subgroup.

\code{zapply( x , by, FUN , ...)} where \code{x} is a vector

is equivalent to

\code{unsplit ( lapply ( split ( x , by ), FUN, ...), by )}

which has the same effect as

\code{tapply( x, by, FUN, ...) [ tapply( x, by) ]}

if \code{FUN} returns a vector of length 1.

If \code{FUN} returns a vector, it is recycled to the length of the input
value.

When the first argument is a data frame:

\code{zapply ( dd, by, FUN, ...)}

uses unsplit - lapply - split to apply \code{FUN} to each sub data frame. In
this case, \code{by} can be a formula that is evaluated in 'dd'.

This syntax makes it easy to compute formulas involving more than one
variable in 'dd'. An example:

\code{zapply( dd, ~gg, function(x) with( x, mean(Var1) / mean(Var2) ) )}

where 'Var1' and 'Var2' are numeric variables and 'gg' a grouping factor in
data frame 'dd'.  Or, using the \code{with} function:

\code{zapply( dd, ~gg, with , mean(Var1) / mean(Var2) )}

\code{cvar} and \code{cvars} are intended to create contextual variables in
model formulas. If 'x' is numerical, \code{cvar} is equivalent to
\code{zapply(x,id,mean)} and \code{cvars} is equivalent to
\code{zapply(x,id,sum)}.

If \code{x} is a factor, \code{cvar} generates the equivalent of a model
matrix for the factor with indicators replaced by the proportion within each
cluster.

\code{dvar} is equivalent to \code{x - cvar(x,by)} and creates what is
commonly known as a version of 'x' that is 'centered within groups' (CWG).
It creates the correct matrix for a factor so that the between group
interpretation of the effect of \code{cvar(x,by)} is that of the 'between
group' or 'compositional' effect of the factor.
}
\description{
Apply a function to each cell of a ragged array, that is to each (non-empty)
group of values given by a unique combination of the levels of certain
variables and, in contrast with \code{tapply}, return within each cell a
vector of the same length as the cell, which are then ordered to match the
corresponding positions of the cells in the input.

Double zap function to be documented in zapply
}
\details{
\code{zapply} is very similar to \code{\link[stats]{ave}} in \code{package:stats}. They
differ in the way they treat missing values in the clustering variables.
\code{ave} treats missing values as if they were legitimate clustering
levels while \code{zapply} returns a value of NA within any cluster formed
by a combination of clustering variable values that includes a value of NA.

\code{zapply} extends the function of \code{tapply(x, by, FUN)[ tapply(x,
by) ]}. The function \code{FUN} is applied to each cell of \code{x} defined
by each value of \code{by}. The result in each cell is recycled to a vector
of the same length as the cell. These vectors are then arranged to match the
input \code{x}.  Thus, if the value returned within each cell is a scalar,
the effect of \code{zapply(x, by, FUN)} is the same as \code{tapply(x, by,
FUN)[ tapply(x, by) ]}.  \code{zapply} extends this use of \code{tapply} by
allowing the value returned within each cell to be a vector of the same
length as the cell.

The \code{zapply.formula} method allows the use of two-sided formula of the
form \code{x ~ a + b} or \code{cbind(x, y) ~ a + b} where the variables on
the left-hand side are used to create a data frame that is given as a first
argument to \code{FUN}. If there is a single variable on the left-hand side
then that variable can be treated as a vector by \code{FUN}.
}
\note{
\code{zapply} tends to be slow when there are many cells and \code{by}
is a factor. This may be due to the need to process all factor levels for
each cell. Turning \code{by} into a numeric or character vector improves
speed: e.g. \code{zapply( x, as.numeric(by), FUN)}.
}
\examples{
\dontrun{
     data( hs )
     head( hs )

     # FUN returns a single value
     hs$ses.mean <- zapply( hs$ses, hs$school, mean, na.rm = T)
     hs$ses.hetero <- zapply ( hs$ses, hs$school, sd , na.rm = T)
     hs.summ <- up( hs, ~school )
     head( hs.summ )   # variables invariant within school

     # FUN returns a vector
     # with 'x' a data frame
     # Note how the 'with' function provides an easy way to write use a
     #   formula as the '...' variable.

     hs$minority.prop <- zapply( hs, ~ school, with, mean( Minority == "Yes"))

     # equivalently:

     hs$minority.prop <- zapply( hs$Minority, hs$school, mean)

     # on very large data frames with many columns that are not used, the 'data frame'
     # version of 'zapply' can be very slow in comparison with 'vector' version.

     # In contrast with 'tapply' 'FUN' can return a vector, e.g. ranks within groups

     hs$mathach.rank <- zapply( hs, ~ school, with , rank(mathach))

     # cvar and dvar in multilevel models

     library( nlme )
     data ( hs )
     fit <- lme( mathach ~ Minority * Sector, hs, random = ~ 1 | school)
     summary ( fit )

     fit.contextual <- lme( mathach ~ (Minority + cvar(Minority, school)) * Sector,
                       hs, random = ~ 1| school)
     summary(fit.contextual) # contextual effect of cvar(Minority)

     fit.compositional <- lme( mathach ~ (dvar(Minority,school) + cvar(Minority, school)) * Sector,
                       hs, random = ~ 1| school)
     summary(fit.compositional) # compositional effect of cvar(Minority)
}
}
